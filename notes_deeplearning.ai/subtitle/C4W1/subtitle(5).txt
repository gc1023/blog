You've seen how convolutions over 2D images works. Now, let's see how you can implement convolutions over not just 2D images, but over three dimensional volumes. Let's start with an example. Let's say you want to detect features not just in a grayscale image, but in a RGB image. So, RGB image might be inside a six by six image, it could be six by six by three, where the three here corresponds to the three color channels. So, you can think of this as a stack of three six by six images. In order to detect edges or some other feature in this image, you convolve not to have a three by three filter as you had previously, but now with also a 3D filter, That's going to be three by three by three. So, the filter itself will also have three layers corresponding to the red, green, and blue channels. So to give these things some names, this first six here, that's the height of the image, that's the width, and this three is the number of channels. And your filter also similarly has a height, a width, and the number of channels. And the number of channels in your image must match the number of channels in your filter. So, these two numbers have to be equal. We'll see on the next slide how this convolution operation actually works, but the output of this will be a four by four image, and notice this is four by four by one, there's no longer a three at the end. Let's go through in detail how this works, but let's use a more nicely drawn image. So here is the six by six by three image, and here's the three by three by three filter, and this last number, the number of channels matches between the image and the filter. So, to simplify the drawing of this three by three by three filter, instead of drawing it as a stack of three matrices, I'm also going to sometimes just draw it as this three dimensional cube like that. So, to compute the output of this convolution operation, what you would do is take the three by three by three filter, and first place it in that upper left most position. So, notice that this three by three by three filter has 27 numbers, well, 27 parameters as three cubed. And so what you do is take each of these 27 numbers and multiply them with the corresponding numbers from the red, green, and blue channels of your image. So, take the first nine numbers for red channel, then the three beneath it for the green, and the three beneath it for the blue channel, and multiply it with the corresponding 27 numbers that are I guess covered by this yellow cube shown on the left. Then add up all those numbers, and this gives you this first number in the output. And if you compute the next output, you take this cube and slide it over by one, and again do the 27 multiplications, add up the 27 numbers, that gives you this next output, do it for the next number over, for the next position over, that gives us third output, and so on. That gives you the forth, and then one row down, and then the next one, the next one, the next one, and so on. All right and you get the idea, until at the very end, that's the position you'll have for that final output. So, what does this allow you to do? Well, here's the example. This filter is three by three by three. So, if you want to detect edges in the red channel of the image, then you could have the first filter be one, one, one, minus one minus one minus one, as usual, and have the green channel be all zeros, and have the blue filter be all zeros. And maybe have, if you have these three stack together to form your three by three by three filter, then this would be a filter that detects edges, vertical edges, but only in red channel. Alternatively, if you don't care what color the vertical edge is in, then you might have a filter just like this, where is this one, one, one, minus one, minus one, minus one, in all three channels. So, by setting the second alternative, so the parameters, you then have the edge detector, a three by three by three edge detector, to detects edges in any color. And with different choices of these parameters, you can get different feature detectors, all of these three by three by three filter. And by convention in compute division, when you have an input with a certain height, a certain width, and a certain number of channels, then your filter will have a potential different height, different width, but the same number of channels. And in theory, is possible to have a filter that maybe only looks at the red channel, or maybe a filter that looks at only the green channel and the blue channel. And once again, you notice that convolving a volume, a six by six by three convolve with a three by three by three, that gives a four by four to the output. Now that you know how to convolve on volumes, there's one last idea that'll be crucial for building Convolutional Neural Networks, which is, what if we don't just want to detect vertical edges, what if we want to detect vertical edges and horizontal edges, and maybe 45 degree edges, and maybe 70 degree edges as well. But in other words, what if you want to use multiple filters at the same time. So, here's the picture we had from the previous slide, we had six by six by three convolved with three by three by three, gives four by four, and maybe this is a vertical edge detector, or maybe is learning to detect some other feature. Now, maybe the second filter may be denoted by this orangish color, which could be a horizontal edge detector. So, maybe convolving it with the first filter gives you this first four by four output, and convolving with the second filter gives you a different four by four output. We can do this, then take these two four by four outputs, take this first one, put it in front, and you can take the second filter output and well, let me draw it here, put it at the back as follows, so that by stacking these two together, you end up with a four by four by two output volume. And you can think of the volume as you redraw this is a box I guess, it would maybe look like this. So, this will be a four by four by two output volume, which is the C result of taking your six by six by three image and convolving it while applying two different three by three filters to it, resulting in two four by four outputs that I think it's stacked up to form a four by four by two much volume. And the two here comes from the fact that we used two different filters. So, let's just summarize the dimensions. If you have a n by n by number of channels input image, so in the example this a six by six by three, where n subscript capital C is the number of channels, and you convolve that with a f by f by and again this should be the same n_c, so this was three by three by three. And by convention, this and this, have to be the same number. Then what you get is a n-f+1 by n-f+1 by and then when you use this n_c_prime, is really n_c at the next player. But this is the number of filters that you use. So, this in our example will be four by four by two. And I wrote this assuming that you use a stride of one and no padding, but if you use a different stride of padding then this n-f+1 will be affected in the usual way as we saw in the previous videos. So, this idea of convolution on volumes turns out to be really powerful. Only a small part of it is that you can now operate directly on RGB in which is with three channels. But even more important is that you can now detect two features like vertical and horizontal edges, or 10, or maybe 128, or maybe several hundred different features, and the output will then have a number of channels equal to the number of features you are detecting. And as a note a notation, I've been using your number of channels to denote this last dimension. In the literature, people will also often call this the death of this 3D volume. And both notations, channels or death are commonly used in the literature, but I find death more confusing because usually you talk about the death of the neural network as well. So, I'm going to use the term channels in these videos to refer to the size of this third dimension of these filters. So, now that you know how to implement convolutions over volumes, you now are ready to implement one layer of a convolutional neural network. Let's see how they do that in the next video.